## 라이프 사이클과 스코프

그렇게 어렵지는 않은 개념 :)

---

```
1. 세가지 종류의 스코프
2. 함수 스코프
3. 블럭 스코프
4. 호이스팅
```

<br />

변수나 함수는 '어디'에 생길까?<br />
바로, '스코프'라고 하는 공간에 생긴다.

'스코프'라고 하는 공간은 3가지 종류가 있다.

- 글로벌 스코프 (전역 스코프)<br />
  \: 이름에서도 알 수 있듯이, 애플리케이션이 실행되면 그 즉시 만들어지고, 애플리케이션이 종료되면 그때 사라진다.
- 함수 스코프<br />
  \: 함수를 통해서 만들 수 있는 스코프 공간이다.
- 블록 스코프<br />
  \: 코드를 묶고 있는 공간이라고 하면 모두 블록 스코프가 생긴다.

이렇게 3가지가 있다.

하지만, 단지 함수가 있다고 해서 함수 스코프가 생기고, <br />
블록이 있다고해서 블록 스코프가 생기는 게 아니라<br />
블록이 만들어지고 그 블록 안으로 진입했을 때 생성이 되고,<br />
그 블록이 벗어나면 해당하는 스코프도 사라진다.

함수도 마찬가지로 함수 호출로 진입하면 스코프가 생기고, <br />
벗어나면 즉, 리턴되면 스코프가 사라지는 메커니즘을 가지고 있다.

그러니까 당연히 스코프 공간에 만들어진 변수나 함수는 그 스코프와 삶을 같이 한다고 할 수 있다. <br />
스코프가 생성되면 같이 생성되고,
스코프가 사라지면 같이 사라진다.

🤔..."왜 이런 메커니즘을 갖고있는 걸까?"

자바스크립트는 변수 하나, 함수 하나를 일일히 만들고 생성하고를 제어하지 않게 되어 있고, <br />
'스코프'라고 하는 '일종의 그룹핑 역할을 하는 공간'으로 그 라이프 사이클을 만들게 된다.

🤔..."만들어놓고 끝까지 안지우면 안되나?"

컴퓨터 시스템의 자원이라고 하는 것은 유한한 자원이기에...<br />
무한정으로 쓸 수 있는 자원은 아니기 때문에<br />
필요할 때만 사용하고 필요 없을 땐 버려지는 게<br />
훨씬 효과적으로 적은 자원을 유용하게 쓸 수 있는 메커니즘일 것이다.<br />
그래서 이러게 디자인되어 있다.

<br />

### 함수 스코프

```js
let myname = "jeong";

function foo() {
  let x = 10;
  console.log(x); // 10
}

foo();
console.log(x); // x is not defined
```

스코프의 '중첩'되는 특성

```js
// 전역 스코프가 있고,
let myname = "jeong";

// 전역 스코프 안에 함수 스코프가 있다.
function foo() {
  // 이 함수 스코프는 전역 공간 안에 포함되어 있는 관계라고 볼 수 있다.
  let x = 10;
  // 이런 상황에서 안쪽에 있는 스코프에서는 바깥쪽에 있는 스코프에 접근이 가능하다.
  console.log(myname); // 전역 공간의 myname에 접근할 수 있다.
}
```

함수 스코프도 '중첩'이 가능할까?<br />
YES~

```js
let myname = "jeong";

function foo() {
  let x = 10;

  function bar() {
    let y = 10;

    console.log(x); // 10
    console.log(myname); // jeong
  }
  console.log(y); // y is not defined
}
```

<br />

이처럼 안쪽에선 바깥쪽을 접근할 수 있고, 바깥쪽에선 안쪽으로 접근할 수 없다.<br />

...굉장히 당연한 소리이다. 왜냐하면 지금까지의 맥락으로 보자면<br />
스코프라는 건 진입할 때 생성되는 것인데,<br />
바깥에서 안쪽을 안다는 건 안쪽에 진입했다는 건데,<br />
그런 상황은 이미 실행하는 위치가 바깥쪽이 아니기 때문에 접근 자체가 불가능하다.<br />
그래서 애초에 성립되지 않는 내용이라고 할 수있다.

<br />

### 블록 스코프

```js
let myname = "jeong";

function foo() {
  let x = 10;

  function bar() {
    let y = 10;
  }

  if (x === 10) {
    let x = 100;

    /**
     * 스코프에서 변수를 찾을 땐, 
     * 현재 자기 자신이 있는 스코프에서 찾고 거기서 찾아지지 않으면 바깥에서 찾고, 찾고, ... 
     * 최종적으로 전역 스코프까지 가서 없으면 이제 못 찾는 거고 찾아지면 전역 변수의 스코프로 접근한다.
     * (프로토타입의 메커니즘과 흡사한 탐색 메커니즘을 갖고 있다. 명시적으로 프로토타입이라고 하는 속성을 갖고 있지는 않지만.)
     */
    console.log(x); // 100
  }
}
```

<br />

### 호이스팅

```js
function foo() {
  bar(); // 함수 정의문이 아래 있지만, 실행 된다.

  function bar() {
    // ...
  }
}
```

🤔 "왜 되는걸까?"

바로 '호이스팅' 때문이다.<br />
호이스팅이라고 하는 메커니즘은 스코프가 생성될 때,<br />
그 스코프 안에 만들어야 될 함수나 변수들을 미리 만들고 시작하는 것이다.<br />
그러니까 실제로 코드가 실행되기 전에 이 안에 코드를 쭉 탐색하고 만들 것들을 미리 다 만들어 놓은 다음에 코드를 실행시키는 것이다.

이 호이스팅은 실제로 함수 정의'문'에서는 적용이 되는데,<br />
함수'식'(화살표 함수)에서는 적용이 안된다는 특징을 가진다. :)

```js
function foo() {
  zoo(); // Cannot access 'zoo' before initialization.

  const zoo = () => {
    // ...
  };
}
```
