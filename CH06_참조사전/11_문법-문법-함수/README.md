## 함수

ES6 이후로 학습해야 할 문법 요소의 확장이 굉장히 방대해졌다. <br />
그리고 더구나 지금은 타입스크립트까지 학습해야 한다...😅 <br />
그 방대한 문법 가운데 함수가 차지하고 있는 비중은 굉장히 높다.

함수는 코드를 활용하기 위해 묶는 것이다. <br />
코드는 계산을 하는 것이고, 계산을 하면 결과가 나온다. <br />
정리하자면, 함수는 어떤 목적의 계산을 하는 코드의 묶음이며 <br />
이 묶음을 '호출'이라고 하는 과정을 통해서 코드를 실행시킬 수 있다. <br />
그러면 결과가 나오고 이걸 받아볼 수 있다.

---

```
1. 함수의 원형
2. 값으로의 함수, 이름없는 함수
3. 가변 인자
4. 화살표, 생성기, 비동기 함수
```

<br />

**함수의 원형**

```js
function myFn(x) {
  return x + 100;
}

const result = myFn(10); // 110
```

<br />

**값으로의 함수, 이름없는 함수**

자바스크립트의 함수는 유연성이 굉장히 뛰어나다. <br />
그만큼 다양한 형태를 가질 수 있다.

- 함수가 이름이 없을 수 있다. <br />
  (그러면 호출은 어떻게 해요...? 변수에 넣어서 한다.)

  ```js
  const myFnV2 = function () {
    return 100;
  }; // myFn 함수는 '문'이고, 이 함수는 '식'이 된다. 그래서 세미콜론이 있다. (myFn은 없고 ^^;)
  // JavaScript의 세미콜론은 자동으로 찍어주기 때문에 그 차이를 엄밀히 구분하기 어려운 측면이 있지만, 2가지는 분명히 다르다. '식'과 '문'!

  myFnV2();
  ```
  
 <br />

- 즉시실행함수 (이름없는 함수의 응용버전(!)) <br /> 
  \: 실행하는 순간 값으로 취급해서 바로 호출하고 끝나버린다. <br />
  어플리케이션 내에서 단 한번만 실행해야 코드가 있을 때 사용하는 함수다. <br />
  이상한 모양(!) 때문에 형태적으로는 마치 새로운 문법처럼 보이게 하는 경향성도 있다.

  ```js
  (function () {
    console.log("즉시실행함수");
  })();
  ```

<br />

**함수를 호출하는 3가지 방법 (가변 인자)**

`()`로 호출하는 방법과 함수에서 제공하는 메서드인 call과 apply.

```js
myFnV2();
myFnV2.call();
myFnV2.apply();
```

call과 apply는 특수한 용도로 사용한다. <br />
JavaScript의 인자와 관련이 있다.<br />
(※ 자바스크립트 함수의 특징 중 하나는 함수에서 인자를 1개만 받는다고 해놨어도, <br />
2개(이상)의 인자를 넣거나 심지어 때에 따라 인자를 넣지 않아도 호출이 성공한다.)

만약 함수에 전달되는 인자의 개수를 가변적으로 주고 싶을 때 예제 코드.

```js
function sum() {
  let s = 0;

  for (let i = 0; i < arguments.length; i++) {
    s = s + arguments[i]; // ※ arguments는 유사 배열.
  }

  return s;
}

const result = sum(10, 20, 30);
```

하지만 이렇게 되면, 매번 함수가 어떻게 동작하는지를 매번 코드로 확인해야 한다. 😫 (함수 시그니처의 표현력이 제한된다.) <br />
이런 맥락에서 새롭게 추가된 스펙이 전개 파라미터(rest parameter)다.

```js
// 큰 차이 없어 보일 수 있지만, ...arg를 통해 '표현력'이 높아졌다.
function sum(...args) {
  let s = 0;

  for (let i = 0; i < args.length; i++) {
    s = s + args[i];
  }

  return s;
}

const result = sum(10, 20, 30);

function sum2(a, b, ...args) {
  // 이렇게도 가능하다.
}
```

<br />

**call 과 apply의 공통점과 차이점**

- 공통점 <br />
  \: 첫 번째 인자로 context라고 하는 객체를 받는다.
  ```js
  myFnV2.call(null);
  myFnV2.apply(null);
  ```
- 차이점 <br />
  \: 파라미터의 기술이 다르다.

  ```js
  myFnV2.call(null, 10, 20, 30);
  myFnV2.apply(null, [10, 20, 30]);

  // apply는 배열을 따로 변수에 담는 호출도 가능해 call 보다 더 문법적 유연성을 가진다.
  const arr = [10, 20, 30];
  myFnV2.apply(null, arr);
  ```

<br />

**화살표 함수**

arrow 함수라고 하는 형식은 이름이 기본적으로 없다.<br />
이름 자체를 줄 수 없는 익명 함수가 기본값이다.

익명함수의 원형

```js
(a, b, ...args) {
  let s = 0;

  for (let i = 0; i < args.length; i++) {
    s = s + args[i];
  }

  return s;
}
```

고로 변수에 담아서 사용한다. (+ `=>`)

```js
const sumV2 = (a, b, ...args) => {
  let s = 0;

  for (let i = 0; i < args.length; i++) {
    s = s + args[i];
  }

  return s;
};
```

화살표 함수는 '한 줄 함수'라고도 불린다.

```js
const ten = () => 10; // 결과를 즉시 반환하는 경우 {}를 생략할 수 있다.
const tenV2 = (x) => 100 + x;
// const tenV3 = x => 100 + x; // 인자가 하나면 괄호()도 생략할 수 있다.
```

※ 기호로 쓰는건 단어로 쓰는거보다 적응이 어려워~ 라고 느낄 수 있다. 오직 연습뿐! :)

<br />

**생성기 함수**

굉장히 독특한 함수다.<br />
통상적인 함수의 작동 방식과는 완전히 다르다.<br />
일반적인 함수는 호출하면 그 함수로 진입했다가 계산이 끝나면 결과를 반환하고 함수를 종료하고 다시 호출하면 그 과정을 반복한다. <br />
하지만 제너레이터는 최초에 호출하면 함수가 실행되지 않고 '실행 준비 상태' 로만 만든다. <br />
그리고 객체를 하나 반환하는데 그 객체 안에는 함수가 실행 준비를 마쳤으니 <br />
그 함수를 실행할 '도구'를 담은 객체를 반환한다. <br />
그래서 그 '도구'를 이용해서 함수를 실행하고 멈추고를 할 수 있다. <br />
함수가 종료되지 않았는데, 그 함수에 다시 들어갔다가 다시 나오고... 이런 식으 동작을 할 수 있는게 제너레이터다.

함수의 사용자와 커뮤니케이션 할 수 있는 스펙으로 볼 수있다.

```js
function* gen() {
  yield 10; // return과 유사한 제너레이터 함수의 문법. yield
  yield 20;
  return 30;
}

const g = gen();

g.next();
g.next();
g.next();
```

<br />

**비동기 함수**

'비동기 흐름'을 '문법적'으로는 '동기적'으로 작성할 수 있게 해준다. (매직인가요~~~)<br />
Promise와 callback에 대한 선행학습이 필요하다.

```js
async function myTask() {}
```
